"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ABORT_STRATEGY: () => ABORT_STRATEGY,
  ActionAbortError: () => ActionAbortError,
  default: () => actionExtension
});
module.exports = __toCommonJS(src_exports);
var import_task = __toESM(require("@harlem/task"));

// src/constants.ts
var SENDER = "extension:action";

// src/index.ts
var import_vue = require("vue");

// src/utilities.ts
function getAbortMessage(name, reason) {
  return `Action ${name} has been cancelled. Reason: ${reason || "unknown"}`;
}

// src/errors.ts
var ActionAbortError = class extends Error {
  constructor(name, instanceId, reason) {
    super(getAbortMessage(name, reason));
    this.name = name;
    this.instanceId = instanceId;
    this.reason = reason;
  }
};

// src/index.ts
var import_core = require("@harlem/core");
var import_utilities3 = require("@harlem/utilities");
var ABORT_STRATEGY = {
  error: (name, id, resolve, reject, reason) => {
    reject(new ActionAbortError(name, id, reason));
  },
  warn: (name, id, resolve, reject, reason) => {
    console.warn(getAbortMessage(name, reason));
    resolve();
  }
};
function getOptions(options) {
  return {
    concurrent: true,
    ...options,
    strategies: {
      abort: ABORT_STRATEGY.error,
      ...options == null ? void 0 : options.strategies
    }
  };
}
function actionExtension(options) {
  const rootOptions = getOptions(options);
  return (store) => {
    store.register("extensions", "action", () => rootOptions);
    const actionTasks = /* @__PURE__ */ new Map();
    const actionState = (0, import_vue.reactive)(/* @__PURE__ */ new Map());
    function setActionState(name) {
      const state = {
        runCount: 0,
        instances: /* @__PURE__ */ new Map(),
        errors: /* @__PURE__ */ new Map()
      };
      actionState.set(name, state);
      return state;
    }
    function getActionState(name) {
      return actionState.get(name) || setActionState(name);
    }
    function registerAction(name, options2 = {}) {
      store.register("actions", name, () => options2);
      setActionState(name);
      const tasks = /* @__PURE__ */ new Set();
      actionTasks.set(name, tasks);
      return {
        tasks
      };
    }
    function action(name, body, options2) {
      const {
        tasks
      } = registerAction(name, options2);
      const {
        concurrent,
        autoClearErrors,
        strategies
      } = {
        autoClearErrors: true,
        ...rootOptions,
        ...options2,
        strategies: {
          ...rootOptions.strategies,
          ...options2 == null ? void 0 : options2.strategies
        }
      };
      const mutate = (mutator) => store.write(name, SENDER, mutator);
      const incrementRunCount = () => getActionState(name).runCount += 1;
      return (payload, controller) => {
        const {
          instances,
          errors
        } = getActionState(name);
        if (!concurrent || (0, import_utilities3.typeIsFunction)(concurrent) && !concurrent(payload, Array.from(instances.values()))) {
          abortAction(name, "New instance started on non-concurrent action");
        }
        if (autoClearErrors) {
          errors.clear();
        }
        const task = new import_task.default(async (resolve, reject, controller2, onAbort) => {
          var _a;
          const id = Symbol(name);
          const complete = () => (tasks.delete(task), instances.delete(id));
          const fail = (reason) => strategies.abort(name, id, resolve, reject, reason);
          let result;
          const trigger = (event) => store.emit(event, SENDER, {
            name,
            payload,
            result
          });
          onAbort((reason) => (complete(), fail(reason)));
          instances.set(id, payload);
          trigger(import_core.EVENTS.action.before);
          try {
            const producedPayload = (_a = store.producers.payload(payload)) != null ? _a : payload;
            result = await body(producedPayload, mutate, controller2, onAbort);
            trigger(import_core.EVENTS.action.success);
            incrementRunCount();
            resolve(result);
          } catch (error) {
            if (isActionAbortError(error)) {
              return fail(error.message);
            }
            if (error instanceof DOMException) {
              return fail("Network request cancelled");
            }
            trigger(import_core.EVENTS.action.error);
            incrementRunCount();
            errors.set(id, error);
            reject(error);
          } finally {
            trigger(import_core.EVENTS.action.after);
            complete();
          }
        }, controller);
        tasks.add(task);
        return task;
      };
    }
    function hasActionRun(name) {
      return getActionState(name).runCount > 0;
    }
    function isActionRunning(name, predicate) {
      const payloads = Array.from(getActionState(name).instances.values());
      return !!payloads.length && (!predicate || payloads.some(predicate));
    }
    function isActionFirstRun(name) {
      return !hasActionRun(name) && isActionRunning(name);
    }
    function whenActionIdle(name, predicate, controller) {
      return new import_task.default((resolve, reject, controller2, onAbort) => {
        const isComplete = () => !isActionRunning(name, predicate);
        if (isComplete()) {
          return resolve();
        }
        const unwatch = (0, import_vue.watchEffect)(() => {
          if (isComplete()) {
            unwatch();
            resolve();
          }
        });
        onAbort(() => (unwatch(), resolve()));
      }, controller);
    }
    function hasActionFailed(name) {
      return !!getActionState(name).errors.size;
    }
    function getActionErrors(name) {
      const errors = Array.from(getActionState(name).errors);
      return errors.map(([id, error]) => ({
        id,
        error
      }));
    }
    function isActionAbortError(value) {
      return value instanceof ActionAbortError;
    }
    function resetActionState(name) {
      [].concat(name || Array.from(actionState.keys())).forEach((name2) => setActionState(name2));
    }
    function abortAction(name, reason) {
      [].concat(name).forEach((name2) => {
        const tasks = actionTasks.get(name2);
        if (tasks == null ? void 0 : tasks.size) {
          tasks.forEach((task) => {
            task.abort(reason);
            tasks.delete(task);
          });
        }
      });
    }
    function suppressAbortError(action2) {
      return (payload, controller) => {
        return new import_task.default(async (resolve, reject, controller2, onAbort) => {
          onAbort(() => resolve());
          try {
            const result = await action2(payload, controller2);
            resolve(result);
          } catch (error) {
            isActionAbortError(error) ? resolve() : reject(error);
          }
        }, controller);
      };
    }
    return {
      action,
      abortAction,
      getActionErrors,
      hasActionFailed,
      hasActionRun,
      isActionAbortError,
      isActionFirstRun,
      isActionRunning,
      resetActionState,
      suppressAbortError,
      whenActionIdle
    };
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ABORT_STRATEGY,
  ActionAbortError
});
