// src/index.ts
import Task from "@harlem/task";

// src/constants.ts
var SENDER = "extension:action";

// src/index.ts
import {
  reactive,
  watchEffect
} from "vue";

// src/utilities.ts
function getAbortMessage(name, reason) {
  return `Action ${name} has been cancelled. Reason: ${reason || "unknown"}`;
}

// src/errors.ts
var ActionAbortError = class extends Error {
  constructor(name, instanceId, reason) {
    super(getAbortMessage(name, reason));
    this.name = name;
    this.instanceId = instanceId;
    this.reason = reason;
  }
};

// src/index.ts
import {
  EVENTS
} from "@harlem/core";
import {
  typeIsFunction
} from "@harlem/utilities";
var ABORT_STRATEGY = {
  error: (name, id, resolve, reject, reason) => {
    reject(new ActionAbortError(name, id, reason));
  },
  warn: (name, id, resolve, reject, reason) => {
    console.warn(getAbortMessage(name, reason));
    resolve();
  }
};
function getOptions(options) {
  return {
    concurrent: true,
    ...options,
    strategies: {
      abort: ABORT_STRATEGY.error,
      ...options == null ? void 0 : options.strategies
    }
  };
}
function actionExtension(options) {
  const rootOptions = getOptions(options);
  return (store) => {
    store.register("extensions", "action", () => rootOptions);
    const actionTasks = /* @__PURE__ */ new Map();
    const actionState = reactive(/* @__PURE__ */ new Map());
    function setActionState(name) {
      const state = {
        runCount: 0,
        instances: /* @__PURE__ */ new Map(),
        errors: /* @__PURE__ */ new Map()
      };
      actionState.set(name, state);
      return state;
    }
    function getActionState(name) {
      return actionState.get(name) || setActionState(name);
    }
    function registerAction(name, options2 = {}) {
      store.register("actions", name, () => options2);
      setActionState(name);
      const tasks = /* @__PURE__ */ new Set();
      actionTasks.set(name, tasks);
      return {
        tasks
      };
    }
    function action(name, body, options2) {
      const {
        tasks
      } = registerAction(name, options2);
      const {
        concurrent,
        autoClearErrors,
        strategies
      } = {
        autoClearErrors: true,
        ...rootOptions,
        ...options2,
        strategies: {
          ...rootOptions.strategies,
          ...options2 == null ? void 0 : options2.strategies
        }
      };
      const mutate = (mutator) => store.write(name, SENDER, mutator);
      const incrementRunCount = () => getActionState(name).runCount += 1;
      return (payload, controller) => {
        const {
          instances,
          errors
        } = getActionState(name);
        if (!concurrent || typeIsFunction(concurrent) && !concurrent(payload, Array.from(instances.values()))) {
          abortAction(name, "New instance started on non-concurrent action");
        }
        if (autoClearErrors) {
          errors.clear();
        }
        const task = new Task(async (resolve, reject, controller2, onAbort) => {
          var _a;
          const id = Symbol(name);
          const complete = () => (tasks.delete(task), instances.delete(id));
          const fail = (reason) => strategies.abort(name, id, resolve, reject, reason);
          let result;
          const trigger = (event) => store.emit(event, SENDER, {
            name,
            payload,
            result
          });
          onAbort((reason) => (complete(), fail(reason)));
          instances.set(id, payload);
          trigger(EVENTS.action.before);
          try {
            const producedPayload = (_a = store.producers.payload(payload)) != null ? _a : payload;
            result = await body(producedPayload, mutate, controller2, onAbort);
            trigger(EVENTS.action.success);
            incrementRunCount();
            resolve(result);
          } catch (error) {
            if (isActionAbortError(error)) {
              return fail(error.message);
            }
            if (error instanceof DOMException) {
              return fail("Network request cancelled");
            }
            trigger(EVENTS.action.error);
            incrementRunCount();
            errors.set(id, error);
            reject(error);
          } finally {
            trigger(EVENTS.action.after);
            complete();
          }
        }, controller);
        tasks.add(task);
        return task;
      };
    }
    function hasActionRun(name) {
      return getActionState(name).runCount > 0;
    }
    function isActionRunning(name, predicate) {
      const payloads = Array.from(getActionState(name).instances.values());
      return !!payloads.length && (!predicate || payloads.some(predicate));
    }
    function isActionFirstRun(name) {
      return !hasActionRun(name) && isActionRunning(name);
    }
    function whenActionIdle(name, predicate, controller) {
      return new Task((resolve, reject, controller2, onAbort) => {
        const isComplete = () => !isActionRunning(name, predicate);
        if (isComplete()) {
          return resolve();
        }
        const unwatch = watchEffect(() => {
          if (isComplete()) {
            unwatch();
            resolve();
          }
        });
        onAbort(() => (unwatch(), resolve()));
      }, controller);
    }
    function hasActionFailed(name) {
      return !!getActionState(name).errors.size;
    }
    function getActionErrors(name) {
      const errors = Array.from(getActionState(name).errors);
      return errors.map(([id, error]) => ({
        id,
        error
      }));
    }
    function isActionAbortError(value) {
      return value instanceof ActionAbortError;
    }
    function resetActionState(name) {
      [].concat(name || Array.from(actionState.keys())).forEach((name2) => setActionState(name2));
    }
    function abortAction(name, reason) {
      [].concat(name).forEach((name2) => {
        const tasks = actionTasks.get(name2);
        if (tasks == null ? void 0 : tasks.size) {
          tasks.forEach((task) => {
            task.abort(reason);
            tasks.delete(task);
          });
        }
      });
    }
    function suppressAbortError(action2) {
      return (payload, controller) => {
        return new Task(async (resolve, reject, controller2, onAbort) => {
          onAbort(() => resolve());
          try {
            const result = await action2(payload, controller2);
            resolve(result);
          } catch (error) {
            isActionAbortError(error) ? resolve() : reject(error);
          }
        }, controller);
      };
    }
    return {
      action,
      abortAction,
      getActionErrors,
      hasActionFailed,
      hasActionRun,
      isActionAbortError,
      isActionFirstRun,
      isActionRunning,
      resetActionState,
      suppressAbortError,
      whenActionIdle
    };
  };
}
export {
  ABORT_STRATEGY,
  ActionAbortError,
  actionExtension as default
};
