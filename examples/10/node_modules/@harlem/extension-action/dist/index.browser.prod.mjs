import M from"@harlem/task";var C="extension:action";import{reactive as Q,watchEffect as U}from"vue";function m(e,c){return`Action ${e} has been cancelled. Reason: ${c||"unknown"}`}var A=class extends Error{constructor(s,f,i){super(m(s,i));this.name=s,this.instanceId=f,this.reason=i}};import{EVENTS as S}from"@harlem/core";import{typeIsFunction as W}from"@harlem/utilities";var X={error:(e,c,s,f,i)=>{f(new A(e,c,i))},warn:(e,c,s,f,i)=>{console.warn(m(e,i)),s()}};function Z(e){return{concurrent:!0,...e,strategies:{abort:X.error,...e==null?void 0:e.strategies}}}function tt(e){let c=Z(e);return s=>{s.register("extensions","action",()=>c);let f=new Map,i=Q(new Map);function b(t){let r={runCount:0,instances:new Map,errors:new Map};return i.set(t,r),r}function d(t){return i.get(t)||b(t)}function j(t,r={}){s.register("actions",t,()=>r),b(t);let n=new Set;return f.set(t,n),{tasks:n}}function q(t,r,n){let{tasks:o}=j(t,n),{concurrent:u,autoClearErrors:w,strategies:T}={autoClearErrors:!0,...c,...n,strategies:{...c.strategies,...n==null?void 0:n.strategies}},l=g=>s.write(t,C,g),y=()=>d(t).runCount+=1;return(g,K)=>{let{instances:R,errors:B}=d(t);(!u||W(u)&&!u(g,Array.from(R.values())))&&I(t,"New instance started on non-concurrent action"),w&&B.clear();let h=new M(async(D,N,L,F)=>{var $;let p=Symbol(t),z=()=>(o.delete(h),R.delete(p)),x=a=>T.abort(t,p,D,N,a),O,P=a=>s.emit(a,C,{name:t,payload:g,result:O});F(a=>(z(),x(a))),R.set(p,g),P(S.action.before);try{let a=($=s.producers.payload(g))!=null?$:g;O=await r(a,l,L,F),P(S.action.success),y(),D(O)}catch(a){if(k(a))return x(a.message);if(a instanceof DOMException)return x("Network request cancelled");P(S.action.error),y(),B.set(p,a),N(a)}finally{P(S.action.after),z()}},K);return o.add(h),h}}function v(t){return d(t).runCount>0}function E(t,r){let n=Array.from(d(t).instances.values());return!!n.length&&(!r||n.some(r))}function G(t){return!v(t)&&E(t)}function V(t,r,n){return new M((o,u,w,T)=>{let l=()=>!E(t,r);if(l())return o();let y=U(()=>{l()&&(y(),o())});T(()=>(y(),o()))},n)}function Y(t){return!!d(t).errors.size}function _(t){return Array.from(d(t).errors).map(([n,o])=>({id:n,error:o}))}function k(t){return t instanceof A}function H(t){[].concat(t||Array.from(i.keys())).forEach(r=>b(r))}function I(t,r){[].concat(t).forEach(n=>{let o=f.get(n);o!=null&&o.size&&o.forEach(u=>{u.abort(r),o.delete(u)})})}function J(t){return(r,n)=>new M(async(o,u,w,T)=>{T(()=>o());try{let l=await t(r,w);o(l)}catch(l){k(l)?o():u(l)}},n)}return{action:q,abortAction:I,getActionErrors:_,hasActionFailed:Y,hasActionRun:v,isActionAbortError:k,isActionFirstRun:G,isActionRunning:E,resetActionState:H,suppressAbortError:J,whenActionIdle:V}}}export{X as ABORT_STRATEGY,A as ActionAbortError,tt as default};
