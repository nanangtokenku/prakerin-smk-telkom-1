import Task, { TaskAbortCallback } from '@harlem/task';
import { BaseState, Mutator, InternalStore } from '@harlem/core';

declare class ActionAbortError extends Error {
    name: string;
    instanceId: symbol;
    reason?: unknown;
    constructor(name: string, instanceId: symbol, reason?: unknown);
}

type ActionBody<TState extends BaseState, TPayload = undefined, TResult = void> = (payload: TPayload, mutator: (mutate: Mutator<TState, undefined, void>) => void, controller: AbortController, onAbort: (callback: TaskAbortCallback) => void) => Promise<TResult>;
type Action<TPayload, TResult = void> = undefined extends TPayload ? (payload?: TPayload, controller?: AbortController) => Task<TResult> : (payload: TPayload, controller?: AbortController) => Task<TResult>;
type ActionPredicate<TPayload = unknown> = (payload?: TPayload) => boolean;
type ActionAbortStrategy = (name: string, id: symbol, resolve: (value?: any) => void, reject: (reason?: unknown) => void, reason?: unknown) => void;
interface Options {
    strategies: ActionStrategies;
    concurrent: boolean | ((payload: unknown, runningPayloads: unknown[]) => boolean);
}
interface ActionStrategies {
    abort: ActionAbortStrategy;
}
interface ActionAbortStrategies {
    error: ActionAbortStrategy;
    warn: ActionAbortStrategy;
}
interface ActionState<TPayload = unknown> {
    runCount: number;
    instances: Map<symbol, TPayload>;
    errors: Map<symbol, unknown>;
}
interface ActionOptions<TPayload> {
    concurrent: boolean | ((payload: TPayload, runningPayloads: TPayload[]) => boolean);
    autoClearErrors: boolean;
    suppressAbortErrors: boolean;
    strategies: ActionStrategies;
}

declare const ABORT_STRATEGY: ActionAbortStrategies;
declare function actionExtension<TState extends BaseState>(options?: Partial<Options>): (store: InternalStore<TState>) => {
    action: <TPayload, TResult = void>(name: string, body: ActionBody<TState, TPayload, TResult>, options?: Partial<ActionOptions<TPayload>> | undefined) => Action<TPayload, TResult>;
    abortAction: (name: string | string[], reason?: unknown) => void;
    getActionErrors: (name: string) => {
        id: symbol;
        error: unknown;
    }[];
    hasActionFailed: (name: string) => boolean;
    hasActionRun: (name: string) => boolean;
    isActionAbortError: (value: unknown) => value is ActionAbortError;
    isActionFirstRun: (name: string) => boolean;
    isActionRunning: <TPayload_1 = unknown>(name: string, predicate?: ActionPredicate<TPayload_1> | undefined) => boolean;
    resetActionState: (name?: string | string[]) => void;
    suppressAbortError: <TPayload_2, TResult_1>(action: Action<TPayload_2, TResult_1>) => Action<TPayload_2, TResult_1 | undefined>;
    whenActionIdle: <TPayload_3 = unknown>(name: string, predicate?: ActionPredicate<TPayload_3> | undefined, controller?: AbortController) => Task<void>;
};

export { ABORT_STRATEGY, Action, ActionAbortError, ActionAbortStrategies, ActionAbortStrategy, ActionBody, ActionOptions, ActionPredicate, ActionState, ActionStrategies, Options, actionExtension as default };
