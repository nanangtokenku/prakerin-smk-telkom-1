function W(){let o=new Map;function E(c,u){let l=o.get(c)||new Set;return l.add(u),o.set(c,l),{dispose:()=>p(c,u)}}function p(c,u){let l=o.get(c);!l||(l.delete(u),l.size||o.delete(c))}function w(c,u){let l=y=>{u(y),p(c,l)};return E(c,l)}function x(c,u){let l=o.get(c);l&&l.forEach(y=>y(u))}return{on:E,off:p,once:w,emit:x}}import{objectClone as _}from"@harlem/utilities";var g="core",e={core:{installed:"core:installed"},store:{created:"store:created",ready:"store:ready",destroyed:"store:destroyed"},mutation:{before:"mutation:before",after:"mutation:after",success:"mutation:success",error:"mutation:error"},action:{before:"action:before",after:"action:after",success:"action:success",error:"action:error"},ssr:{initServer:"ssr:init:server",initClient:"ssr:init:client"},devtools:{update:"devtools:update",reset:"devtools:reset"}},z={snapshot:"core:snapshot",reset:"core:reset"},q={read:o=>o,write:o=>o,payload:o=>_(o)},tt={prefix:"$harlem:",pattern:/^\$harlem:/};import{computed as et,effectScope as nt,reactive as rt,readonly as ot}from"vue";import{functionIdentity as X,objectClone as J,objectFromPath as st,objectSet as at,objectTrace as it}from"@harlem/utilities";function Y(o,E){return p=>{p&&p.store===o&&E(p)}}function K(o,E,p,w){var Q;let{allowsOverwrite:x,producers:c}={allowsOverwrite:!0,...w,producers:{...q,...w==null?void 0:w.producers}},u={},l=new Map,y=nt(),a=new Set,i=!1,f=rt(E),v=ot(f),R;function A(t,n,s){if(!y.active||i)return;let d={data:s,sender:n,store:o};p.emit(t,d)}function r(t,n){return p.on(t,Y(o,n))}function O(t,n){return p.once(t,Y(o,n))}function m(t){return y.run(t)}function N(t,n){var s;return!!((s=u[t])!=null&&s.has(n))}function V(t,n){var s;return(s=u[t])==null?void 0:s.get(n)}function B(t,n,s,d="other"){if(!n)throw new Error("Registration name cannot be empty");if(t in u||(u[t]=new Map),!x&&N(t,n))throw new Error(`A ${t} named ${n} has already been registered on this store`);u[t].set(n,{type:d,producer:s})}function j(t,n){var s;(s=u[t])==null||s.delete(n)}function C(t){i=!0;try{return t()}finally{i=!1}}function L(t,n){let s=m(()=>et(()=>n(v)));return B("getters",t,()=>s.value,"computed"),s}function D(t,n,s,d){var P,b;if(!y.active)throw new Error("The current store has been destroyed. Mutations can no longer take place.");if(a.has(t))throw new Error("Circular mutation reference detected. Avoid calling mutations inside other mutations to prevent circular references.");a.add(t);let S,h=T=>A(T,n,{name:t,payload:d,result:S});h(e.mutation.before);try{let T=(P=c.write(f))!=null?P:f,G=(b=c.payload(d))!=null?b:d;S=s(T,G),h(e.mutation.success)}catch(T){throw h(e.mutation.error),T}finally{a.delete(t),h(e.mutation.after)}return S}function $(t,n){let s=d=>D(t,g,n,d);return B("mutations",t,()=>s),s}function U(t,n){let s=S=>M(t,g,S),d=async S=>{var b;let h,P=T=>A(T,g,{name:t,payload:S,result:h});P(e.action.before);try{let T=(b=c.payload(S))!=null?b:S;h=await n(T,s),P(e.action.success)}catch(T){throw P(e.action.error),T}finally{P(e.action.after)}return h};return B("actions",t,()=>d),d}function k(){let t=J(E),{value:n,getNodes:s,resetNodes:d}=it();return{apply:(h=X,P=z.snapshot)=>{M(P,g,b=>{if(!t)return console.warn("Couldn't find snapshot for this operation!");d(),h(n);let T=s(),G=st(t,T);at(b,T,J(G))})},get state(){return J(t)}}}function I(t=X){R==null||R.apply(t,z.reset)}function M(t,n,s,d){let S=()=>D(t,n,s,void 0);return d?C(S):S()}function F(){y.stop()}O(e.store.ready,()=>R=k()),r(e.devtools.reset,()=>I());let H=(Q=c.read(v))!=null?Q:v;return{name:o,allowsOverwrite:x,flags:l,producers:c,registrations:u,on:r,once:O,emit:A,state:H,getter:L,mutation:$,action:U,write:M,snapshot:k,reset:I,register:B,unregister:j,hasRegistration:N,getRegistration:V,track:m,suppress:C,destroy:F}}import{matchGetFilter as ct,objectLock as ut,typeIsFunction as lt,typeIsMatchable as dt}from"@harlem/utilities";function Z(){let o=W(),E=new Map,p=!1;function w(a){let i=E.get(a);if(i&&!i.allowsOverwrite)throw new Error(`A store named ${a} has already been registered.`)}function x(a,i){let f=()=>{a.emit(e.ssr.initClient,g,i),a.emit(e.store.created,g,i),a.emit(e.ssr.initServer,g,i),a.emit(e.store.ready,g,i),a.emit(e.devtools.update,g,i)};if(p)return f();o.once(e.core.installed,f)}function c(a,i){return i.reduce((f,v)=>{let R={};try{R=v(a)||{}}catch(A){R={}}return{...f,...R}},{})}function u(a,i){if(!lt(a))return;let f=ut(E,["set","delete","clear"]);try{a(i,o,f)}catch(v){console.warn("Failed to install Harlem plugin. Skipping.")}}function l(a,i,f){let{allowsOverwrite:v,producers:R,extensions:A}={allowsOverwrite:!0,extensions:[],...f};w(a);let r=K(a,i,o,{allowsOverwrite:v,producers:R}),O=()=>{E.delete(a),r.destroy(),r.emit(e.store.destroyed,g,i),r.emit(e.devtools.update,g,i)},m=k=>(I,M)=>{let F=ct(dt(I)?I:{include:I});return r.on(k,H=>{H&&F(H.data.name)&&M(H.data)})},N=m(e.mutation.before),V=m(e.mutation.after),B=m(e.mutation.success),j=m(e.mutation.error),C=m(e.action.before),L=m(e.action.after),D=m(e.action.success),$=m(e.action.error),U=c(r,A);return E.set(a,r),x(r,i),{destroy:O,onBeforeMutation:N,onAfterMutation:V,onMutationSuccess:B,onMutationError:j,onBeforeAction:C,onAfterAction:L,onActionSuccess:D,onActionError:$,state:r.state,getter:r.getter.bind(r),mutation:r.mutation.bind(r),action:r.action.bind(r),snapshot:r.snapshot.bind(r),reset:r.reset.bind(r),suppress:r.suppress.bind(r),on:r.on.bind(r),once:r.once.bind(r),...U}}function y(a){return{install(i){let{plugins:f}={plugins:[],...a};f&&f.forEach(v=>u(v,i)),p=!0,o.emit(e.core.installed)}}}return{createVuePlugin:y,createStore:l,on:o.on,once:o.once,off:o.off}}var{on:wt,off:bt,once:xt,createVuePlugin:At,createStore:Bt}=Z();window.$harlem={createInstance:Z};export{e as EVENTS,tt as INTERNAL,q as PRODUCERS,Z as createInstance,Bt as createStore,At as createVuePlugin,bt as off,wt as on,xt as once};
