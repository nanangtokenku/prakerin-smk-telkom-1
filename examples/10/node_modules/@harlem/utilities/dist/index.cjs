"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  functionIdentity: () => identity,
  matchGetFilter: () => getFilter,
  matchNormalise: () => normalise,
  objectClone: () => clone,
  objectFromPath: () => fromPath,
  objectLock: () => lock,
  objectOmit: () => omit,
  objectOverwrite: () => overwrite,
  objectSet: () => setObjectValue,
  objectToPath: () => toPath,
  objectTrace: () => traceObject,
  typeGetType: () => getType,
  typeIsArray: () => isArray,
  typeIsFunction: () => isFunction,
  typeIsMatchable: () => isMatchable,
  typeIsNil: () => isNil,
  typeIsObject: () => isObject,
  typeIsString: () => isString
});
module.exports = __toCommonJS(src_exports);

// src/function/identity.ts
function identity(value) {
  return value;
}

// src/type/get-type.ts
function getType(input) {
  return Object.prototype.toString.call(input).slice(8, -1).toLowerCase();
}

// src/type/is-function.ts
function isFunction(value) {
  return getType(value) === "function";
}

// src/type/is-string.ts
function isString(value) {
  return getType(value) === "string";
}

// src/match/normalise.ts
function normalise(matcher) {
  if (matcher === "*") {
    return () => true;
  }
  if (isFunction(matcher)) {
    return matcher;
  }
  const patterns = [].concat(matcher).map(
    (pattern) => isString(pattern) ? new RegExp(pattern) : pattern
  );
  return (value) => patterns.some((pattern) => pattern.test(value));
}

// src/match/get-filter.ts
function getFilter({
  include = "*",
  exclude = []
}) {
  const includeMatcher = normalise(include);
  const excludeMatcher = normalise(exclude);
  return (value) => includeMatcher(value) && !excludeMatcher(value);
}

// src/object/clone.ts
var import_vue = require("vue");
function cloneIdentity(input) {
  return input;
}
function cloneBasic(input) {
  return new input.constructor(input);
}
function cloneRegex(input) {
  const clonedRegex = new RegExp(input.source);
  clonedRegex.lastIndex = input.lastIndex;
  return clonedRegex;
}
function cloneSymbol(input) {
  return Object(Symbol.prototype.valueOf.call(input));
}
function cloneObject(input) {
  const output = {};
  for (const key in input) {
    output[key] = clone(input[key]);
  }
  return output;
}
function cloneArray(input) {
  return input.map(clone);
}
function cloneSet(input) {
  const output = /* @__PURE__ */ new Set();
  input.forEach((value) => {
    output.add(clone(value));
  });
  return output;
}
function cloneMap(input) {
  const output = /* @__PURE__ */ new Map();
  input.forEach((value, key) => {
    output.set(key, clone(value));
  });
  return output;
}
var CLONE_MAP = {
  default: cloneIdentity,
  null: cloneIdentity,
  undefined: cloneIdentity,
  boolean: cloneBasic,
  number: cloneBasic,
  string: cloneBasic,
  error: cloneBasic,
  date: cloneBasic,
  regexp: cloneRegex,
  function: cloneIdentity,
  symbol: cloneSymbol,
  array: cloneArray,
  object: cloneObject,
  map: cloneMap,
  set: cloneSet
};
function clone(value) {
  const input = (0, import_vue.unref)(value);
  if (typeof input !== "object" || input === null) {
    return input;
  }
  const type = getType(input);
  const cloner = CLONE_MAP[type] || CLONE_MAP.default;
  return cloner(input);
}

// src/type/is-array.ts
function isArray(value) {
  return getType(value) === "array";
}

// src/object/from-path.ts
function fromPath(value, path) {
  const nodes = isArray(path) ? path : path.split("/");
  return nodes.reduce((branch, node) => branch[node], value);
}

// src/object/lock.ts
function lock(input, exclusions) {
  return new Proxy(input, {
    get(target, prop) {
      if (exclusions.includes(prop)) {
        throw new Error(`Access to property '${prop}' is denied`);
      }
      const value = target[prop];
      if (typeof value === "function") {
        return (...args) => Reflect.apply(value, target, args);
      }
      return value;
    }
  });
}

// src/object/omit.ts
function omit(value, matcher) {
  const output = {};
  const filter = normalise(matcher);
  for (const key in value) {
    if (!filter(key)) {
      output[key] = value[key];
    }
  }
  return output;
}

// src/object/overwrite.ts
function overwrite(target, source) {
  if (typeof target !== "object" || typeof source !== "object") {
    return target;
  }
  for (const prop in target) {
    if (!(prop in source)) {
      delete target[prop];
    }
  }
  return Object.assign(target, source);
}

// src/type/is-nil.ts
function isNil(value) {
  return value == null;
}

// src/object/set.ts
function setObjectValue(target, path, value) {
  const nodes = (isArray(path) ? path : path.split("/")).slice();
  const key = nodes.pop();
  if (isNil(key) || key === "") {
    return overwrite(target, value);
  }
  const parent = fromPath(target, nodes);
  parent[key] = value;
}

// src/object/to-path.ts
function toPath(nodes) {
  return nodes.reduceRight((path, node) => {
    const nodeStr = node.toString();
    const segment = isNaN(parseInt(nodeStr, 10)) ? `/${node.toString()}` : `[${node.toString()}]`;
    return segment + path.toString();
  }, "").toString();
}

// src/object/trace.ts
function traceObjectPath(onAccess) {
  return new Proxy({}, {
    get(target, key) {
      onAccess(key);
      return traceObjectPath(onAccess);
    }
  });
}
function traceObject() {
  const nodes = /* @__PURE__ */ new Set();
  const value = traceObjectPath((key) => nodes.add(key));
  const getNodes = () => Array.from(nodes);
  const resetNodes = () => nodes.clear();
  return {
    value,
    getNodes,
    resetNodes
  };
}

// src/type/is-object.ts
function isObject(value) {
  return getType(value) === "object";
}

// src/type/is-matchable.ts
function isMatchable(value) {
  return isObject(value) && "include" in value && "exclude" in value;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  functionIdentity,
  matchGetFilter,
  matchNormalise,
  objectClone,
  objectFromPath,
  objectLock,
  objectOmit,
  objectOverwrite,
  objectSet,
  objectToPath,
  objectTrace,
  typeGetType,
  typeIsArray,
  typeIsFunction,
  typeIsMatchable,
  typeIsNil,
  typeIsObject,
  typeIsString
});
