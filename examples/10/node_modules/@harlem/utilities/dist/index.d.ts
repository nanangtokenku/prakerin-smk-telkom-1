import { UnwrapRef } from 'vue';

declare function identity<TValue>(value: TValue): TValue;

type UnionToIntersection<TValue> = (TValue extends any ? (arg: TValue) => any : never) extends ((arg: infer I) => void) ? I : never;
type OneOrMore<TValue> = TValue | TValue[];
type Predicate<TValue> = (value: TValue) => boolean;
type Matcher = OneOrMore<string | RegExp> | Predicate<string>;
interface Constructable<TValue = unknown> {
    constructor: new (...args: unknown[]) => TValue;
}
interface Disposable {
    dispose(): void;
}
interface Matchable {
    include: Matcher;
    exclude: Matcher;
}
type RuntimeType = 'boolean' | 'number' | 'string' | 'error' | 'date' | 'regexp' | 'function' | 'symbol' | 'array' | 'object' | 'map' | 'set' | 'null' | 'undefined';

declare function normalise(matcher: Matcher): Predicate<string>;

declare function getFilter({ include, exclude, }: Partial<Matchable>): Predicate<string>;

declare function clone<TValue = unknown>(value: TValue): UnwrapRef<TValue>;

declare function fromPath<TValue extends object>(value: TValue, path: string | PropertyKey[]): unknown;

declare function lock<T extends object>(input: T, exclusions: (keyof T)[]): T;

declare function omit<TValue extends object>(value: TValue, matcher: Matcher): TValue;

declare function overwrite<TTarget extends object, TSource extends object>(target: TTarget, source: TSource): TTarget | TSource;

declare function setObjectValue<TTarget extends object>(target: TTarget, path: string | PropertyKey[], value: any): any;

declare function toPath(nodes: PropertyKey[]): string;

declare function traceObject<TValue extends object>(): {
    value: TValue;
    getNodes: () => PropertyKey[];
    resetNodes: () => void;
};

declare function getType(input: unknown): RuntimeType;

declare function isArray(value: unknown): value is unknown[];

declare function isFunction(value: unknown): value is Function;

declare function isMatchable(value: unknown): value is Matchable;

declare function isNil(value: unknown): value is null | undefined;

declare function isObject(value: unknown): value is object;

declare function isString(value: unknown): value is string;

export { Constructable, Disposable, Matchable, Matcher, OneOrMore, Predicate, RuntimeType, UnionToIntersection, identity as functionIdentity, getFilter as matchGetFilter, normalise as matchNormalise, clone as objectClone, fromPath as objectFromPath, lock as objectLock, omit as objectOmit, overwrite as objectOverwrite, setObjectValue as objectSet, toPath as objectToPath, traceObject as objectTrace, getType as typeGetType, isArray as typeIsArray, isFunction as typeIsFunction, isMatchable as typeIsMatchable, isNil as typeIsNil, isObject as typeIsObject, isString as typeIsString };
