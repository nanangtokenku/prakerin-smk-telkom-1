"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  TaskAbortError: () => TaskAbortError,
  default: () => Task
});
module.exports = __toCommonJS(src_exports);

// src/errors.ts
var TaskAbortError = class extends Error {
  constructor(reason) {
    super("Task aborted");
    this.reason = reason;
  }
};

// src/index.ts
var Task = class extends Promise {
  constructor(executor, controller = new AbortController()) {
    if (controller.signal.aborted) {
      throw new Error("Cannot attach task to an already aborted controller");
    }
    const listeners = /* @__PURE__ */ new Set();
    let isAborting = false;
    let finaliser;
    super((_resolve, _reject) => {
      const resolve = (value) => execResolution(() => _resolve(value));
      const reject = (reason) => execResolution(() => _reject(reason));
      const onAbort = (callback) => listeners.add(callback);
      const dispose = () => controller.signal.removeEventListener("abort", abort);
      const execResolution = (resolution) => {
        if (isAborting) {
          finaliser = finaliser || resolution;
        } else {
          dispose();
          resolution();
        }
      };
      const abort = () => {
        isAborting = true;
        listeners.forEach((listener) => {
          try {
            listener(this.abortReason);
          } finally {
            listeners.delete(listener);
          }
        });
        isAborting = false;
        const finalise = finaliser || ((reason) => _reject(new TaskAbortError(reason)));
        dispose();
        finalise(this.abortReason);
      };
      controller.signal.addEventListener("abort", abort);
      executor(resolve, reject, controller, onAbort);
    });
    this.controller = controller;
  }
  static isTask(value) {
    return value instanceof Task;
  }
  get signal() {
    return this.controller.signal;
  }
  get hasAborted() {
    return this.signal.aborted;
  }
  abort(reason) {
    this.abortReason = reason;
    this.controller.abort();
    return this;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TaskAbortError
});
