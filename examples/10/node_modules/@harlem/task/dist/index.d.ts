type Product<TResult = void> = (...args: any[]) => TResult;
type TaskResolve<TResult> = (value: TResult | PromiseLike<TResult>) => void;
type TaskReject = (reason?: unknown) => unknown;
type TaskAbortCallback = (reason?: unknown) => void;
type TaskExecutor<TResult> = (resolve: TaskResolve<TResult>, reject: TaskReject, controller: AbortController, onAbort: (callback: TaskAbortCallback) => void) => void;

declare class TaskAbortError extends Error {
    reason: any;
    constructor(reason?: any);
}

declare class Task<TResult = void> extends Promise<TResult> {
    private controller;
    private abortReason;
    constructor(executor: TaskExecutor<TResult>, controller?: AbortController);
    static isTask(value: unknown): value is Task;
    get signal(): AbortSignal;
    get hasAborted(): boolean;
    abort(reason?: unknown): this;
}

export { Product, TaskAbortCallback, TaskAbortError, TaskExecutor, TaskReject, TaskResolve, Task as default };
