"use strict";var u=Object.defineProperty;var R=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var x=Object.prototype.hasOwnProperty;var v=(s,o)=>{for(var t in o)u(s,t,{get:o[t],enumerable:!0})},w=(s,o,t,a)=>{if(o&&typeof o=="object"||typeof o=="function")for(let r of m(o))!x.call(s,r)&&r!==t&&u(s,r,{get:()=>o[r],enumerable:!(a=R(o,r))||a.enumerable});return s};var y=s=>w(u({},"__esModule",{value:!0}),s);var C={};v(C,{TaskAbortError:()=>l,default:()=>n});module.exports=y(C);var l=class extends Error{constructor(t){super("Task aborted");this.reason=t}};var n=class extends Promise{constructor(t,a=new AbortController){if(a.signal.aborted)throw new Error("Cannot attach task to an already aborted controller");let r=new Set,c=!1,b;super((k,d)=>{let T=e=>f(()=>k(e)),g=e=>f(()=>d(e)),A=e=>r.add(e),p=()=>a.signal.removeEventListener("abort",h),f=e=>{c?b=b||e:(p(),e())},h=()=>{c=!0,r.forEach(i=>{try{i(this.abortReason)}finally{r.delete(i)}}),c=!1;let e=b||(i=>d(new l(i)));p(),e(this.abortReason)};a.signal.addEventListener("abort",h),t(T,g,a,A)});this.controller=a}static isTask(t){return t instanceof n}get signal(){return this.controller.signal}get hasAborted(){return this.signal.aborted}abort(t){return this.abortReason=t,this.controller.abort(),this}};0&&(module.exports={TaskAbortError});
