"use strict";
(() => {
  // src/errors.ts
  var TaskAbortError = class extends Error {
    constructor(reason) {
      super("Task aborted");
      this.reason = reason;
    }
  };

  // src/index.ts
  var Task = class extends Promise {
    constructor(executor, controller = new AbortController()) {
      if (controller.signal.aborted) {
        throw new Error("Cannot attach task to an already aborted controller");
      }
      const listeners = /* @__PURE__ */ new Set();
      let isAborting = false;
      let finaliser;
      super((_resolve, _reject) => {
        const resolve = (value) => execResolution(() => _resolve(value));
        const reject = (reason) => execResolution(() => _reject(reason));
        const onAbort = (callback) => listeners.add(callback);
        const dispose = () => controller.signal.removeEventListener("abort", abort);
        const execResolution = (resolution) => {
          if (isAborting) {
            finaliser = finaliser || resolution;
          } else {
            dispose();
            resolution();
          }
        };
        const abort = () => {
          isAborting = true;
          listeners.forEach((listener) => {
            try {
              listener(this.abortReason);
            } finally {
              listeners.delete(listener);
            }
          });
          isAborting = false;
          const finalise = finaliser || ((reason) => _reject(new TaskAbortError(reason)));
          dispose();
          finalise(this.abortReason);
        };
        controller.signal.addEventListener("abort", abort);
        executor(resolve, reject, controller, onAbort);
      });
      this.controller = controller;
    }
    static isTask(value) {
      return value instanceof Task;
    }
    get signal() {
      return this.controller.signal;
    }
    get hasAborted() {
      return this.signal.aborted;
    }
    abort(reason) {
      this.abortReason = reason;
      this.controller.abort();
      return this;
    }
  };
})();
