import {
  unref
} from "./chunk-QO6ZHO7P.js";

// node_modules/@harlem/utilities/dist/index.bundler.mjs
function identity(value) {
  return value;
}
function getType(input) {
  return Object.prototype.toString.call(input).slice(8, -1).toLowerCase();
}
function isFunction(value) {
  return getType(value) === "function";
}
function isString(value) {
  return getType(value) === "string";
}
function normalise(matcher) {
  if (matcher === "*") {
    return () => true;
  }
  if (isFunction(matcher)) {
    return matcher;
  }
  const patterns = [].concat(matcher).map(
    (pattern) => isString(pattern) ? new RegExp(pattern) : pattern
  );
  return (value) => patterns.some((pattern) => pattern.test(value));
}
function getFilter({
  include = "*",
  exclude = []
}) {
  const includeMatcher = normalise(include);
  const excludeMatcher = normalise(exclude);
  return (value) => includeMatcher(value) && !excludeMatcher(value);
}
function cloneIdentity(input) {
  return input;
}
function cloneBasic(input) {
  return new input.constructor(input);
}
function cloneRegex(input) {
  const clonedRegex = new RegExp(input.source);
  clonedRegex.lastIndex = input.lastIndex;
  return clonedRegex;
}
function cloneSymbol(input) {
  return Object(Symbol.prototype.valueOf.call(input));
}
function cloneObject(input) {
  const output = {};
  for (const key in input) {
    output[key] = clone(input[key]);
  }
  return output;
}
function cloneArray(input) {
  return input.map(clone);
}
function cloneSet(input) {
  const output = /* @__PURE__ */ new Set();
  input.forEach((value) => {
    output.add(clone(value));
  });
  return output;
}
function cloneMap(input) {
  const output = /* @__PURE__ */ new Map();
  input.forEach((value, key) => {
    output.set(key, clone(value));
  });
  return output;
}
var CLONE_MAP = {
  default: cloneIdentity,
  null: cloneIdentity,
  undefined: cloneIdentity,
  boolean: cloneBasic,
  number: cloneBasic,
  string: cloneBasic,
  error: cloneBasic,
  date: cloneBasic,
  regexp: cloneRegex,
  function: cloneIdentity,
  symbol: cloneSymbol,
  array: cloneArray,
  object: cloneObject,
  map: cloneMap,
  set: cloneSet
};
function clone(value) {
  const input = unref(value);
  if (typeof input !== "object" || input === null) {
    return input;
  }
  const type = getType(input);
  const cloner = CLONE_MAP[type] || CLONE_MAP.default;
  return cloner(input);
}
function isArray(value) {
  return getType(value) === "array";
}
function fromPath(value, path) {
  const nodes = isArray(path) ? path : path.split("/");
  return nodes.reduce((branch, node) => branch[node], value);
}
function lock(input, exclusions) {
  return new Proxy(input, {
    get(target, prop) {
      if (exclusions.includes(prop)) {
        throw new Error(`Access to property '${prop}' is denied`);
      }
      const value = target[prop];
      if (typeof value === "function") {
        return (...args) => Reflect.apply(value, target, args);
      }
      return value;
    }
  });
}
function overwrite(target, source) {
  if (typeof target !== "object" || typeof source !== "object") {
    return target;
  }
  for (const prop in target) {
    if (!(prop in source)) {
      delete target[prop];
    }
  }
  return Object.assign(target, source);
}
function isNil(value) {
  return value == null;
}
function setObjectValue(target, path, value) {
  const nodes = (isArray(path) ? path : path.split("/")).slice();
  const key = nodes.pop();
  if (isNil(key) || key === "") {
    return overwrite(target, value);
  }
  const parent = fromPath(target, nodes);
  parent[key] = value;
}
function toPath(nodes) {
  return nodes.reduceRight((path, node) => {
    const nodeStr = node.toString();
    const segment = isNaN(parseInt(nodeStr, 10)) ? `/${node.toString()}` : `[${node.toString()}]`;
    return segment + path.toString();
  }, "").toString();
}
function traceObjectPath(onAccess) {
  return new Proxy({}, {
    get(target, key) {
      onAccess(key);
      return traceObjectPath(onAccess);
    }
  });
}
function traceObject() {
  const nodes = /* @__PURE__ */ new Set();
  const value = traceObjectPath((key) => nodes.add(key));
  const getNodes = () => Array.from(nodes);
  const resetNodes = () => nodes.clear();
  return {
    value,
    getNodes,
    resetNodes
  };
}
function isObject(value) {
  return getType(value) === "object";
}
function isMatchable(value) {
  return isObject(value) && "include" in value && "exclude" in value;
}

export {
  identity,
  isFunction,
  getFilter,
  clone,
  fromPath,
  lock,
  isNil,
  setObjectValue,
  toPath,
  traceObject,
  isMatchable
};
//# sourceMappingURL=chunk-6VBQTTIA.js.map
