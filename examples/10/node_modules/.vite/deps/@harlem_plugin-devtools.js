import {
  EVENTS
} from "./chunk-A4J6T4K5.js";
import "./chunk-6VBQTTIA.js";
import "./chunk-QO6ZHO7P.js";

// node_modules/@vue/devtools-api/lib/esm/env.js
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
}
var isProxyAvailable = typeof Proxy === "function";

// node_modules/@vue/devtools-api/lib/esm/const.js
var HOOK_SETUP = "devtools-plugin:setup";
var HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";

// node_modules/@vue/devtools-api/lib/esm/time.js
var supported;
var perf;
function isPerformanceSupported() {
  var _a;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof global !== "undefined" && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
    supported = true;
    perf = global.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}

// node_modules/@vue/devtools-api/lib/esm/proxy.js
var ApiProxy = class {
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin.settings) {
      for (const id in plugin.settings) {
        const item = plugin.settings[id];
        defaultSettings[id] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data = JSON.parse(raw);
      Object.assign(currentSettings, data);
    } catch (e) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e) {
        }
        currentSettings = value;
      },
      now() {
        return now();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
};

// node_modules/@vue/devtools-api/lib/esm/index.js
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy)
      setupFn(proxy.proxiedTarget);
  }
}

// node_modules/@harlem/plugin-devtools/dist/index.bundler.mjs
var SENDER = "plugin:devtools";
var DEVTOOLS_ID = "harlem";
var ALL_STORES_ID = "$all";
var OPTIONS = {
  label: "Harlem",
  color: 4244621
};
var MUTATIONS = {
  set: "plugin:devtools:set"
};
function stringComparitor(valueA, valueB) {
  return valueA.localeCompare(valueB);
}
function getInspectorTreeHook(application, stores) {
  return (payload) => {
    const {
      app,
      inspectorId
    } = payload;
    if (app !== application || inspectorId !== DEVTOOLS_ID || stores.size === 0) {
      return;
    }
    const children = Array.from(stores.keys()).sort(stringComparitor).map((name) => ({
      id: name,
      label: name
    }));
    payload.rootNodes = [
      {
        children,
        id: ALL_STORES_ID,
        label: "Stores"
      }
    ];
  };
}
function getRegistrationValue(producer) {
  try {
    return producer();
  } catch (e) {
    return "Failed to compute value...";
  }
}
function getStoreSnapshot(store) {
  return Object.entries(store.registrations).reduce((output, [type, registrations]) => {
    output[type] = Array.from(registrations).sort(([valueA], [valueB]) => stringComparitor(valueA, valueB)).map(([key, { type: type2, producer }]) => ({
      key,
      value: getRegistrationValue(producer),
      editable: false,
      objectType: type2
    }));
    return output;
  }, {
    state: [
      {
        key: store.name,
        value: store.state,
        editable: true,
        objectType: "reactive"
      }
    ]
  });
}
function getStoreSnapshots(stores) {
  return stores.reduce((output, store) => {
    if (!store) {
      return output;
    }
    const snapshot = getStoreSnapshot(store);
    return Object.entries(snapshot).reduce((merges, [key, value]) => {
      merges[key] = (merges[key] || []).concat(value);
      return merges;
    }, {});
  }, {});
}
function getInspectorStateHook(application, stores) {
  return (payload) => {
    const {
      app,
      inspectorId,
      nodeId
    } = payload;
    if (app !== application || inspectorId !== DEVTOOLS_ID || stores.size === 0) {
      return;
    }
    let internalStores = [stores.get(nodeId) || stores.values().next().value];
    if (nodeId === ALL_STORES_ID) {
      internalStores = Array.from(stores.values());
    }
    if (internalStores.length > 0) {
      payload.state = getStoreSnapshots(internalStores);
    }
  };
}
function getInspectorEditHook(application, stores) {
  return (payload) => {
    const {
      app,
      inspectorId,
      nodeId,
      path,
      state,
      set
    } = payload;
    if (app !== application || inspectorId !== DEVTOOLS_ID || stores.size === 0) {
      return;
    }
    const root = path.shift();
    const storeId = nodeId === ALL_STORES_ID ? root || nodeId : nodeId;
    const store = stores.get(storeId);
    if (!store) {
      return;
    }
    store.write(MUTATIONS.set, SENDER, (_state) => set(_state, path, state.value));
  };
}
function getMutationHook(api, logType) {
  return (payload) => {
    if (!payload) {
      return;
    }
    const {
      store
    } = payload;
    api.sendInspectorState(DEVTOOLS_ID);
    api.addTimelineEvent({
      layerId: DEVTOOLS_ID,
      event: {
        logType,
        title: "Mutation",
        subtitle: store,
        groupId: store,
        time: api.now(),
        data: payload,
        meta: {
          store
        }
      }
    });
  };
}
function createDevtoolsPlugin(options) {
  const {
    label,
    color
  } = {
    ...OPTIONS,
    ...options
  };
  return (app, eventBus, stores) => {
    const inspectorTreeHook = getInspectorTreeHook(app, stores);
    const inspectorStateHook = getInspectorStateHook(app, stores);
    const inspectorEditHook = getInspectorEditHook(app, stores);
    const descriptor = {
      app,
      label,
      id: DEVTOOLS_ID,
      logo: "https://harlemjs.com/assets/images/favicon.png",
      homepage: "https://harlemjs.com",
      packageName: "@harlem/plugin-devtools"
    };
    setupDevtoolsPlugin(descriptor, (api) => {
      const successMutationHook = getMutationHook(api);
      const errorMutationHook = getMutationHook(api, "error");
      api.addInspector({
        label,
        id: DEVTOOLS_ID,
        icon: "source",
        treeFilterPlaceholder: "Search stores",
        stateFilterPlaceholder: "Search state",
        nodeActions: [
          {
            icon: "replay",
            tooltip: "Reset store",
            action: (nodeId) => eventBus.emit(EVENTS.devtools.reset, {
              sender: SENDER,
              store: nodeId,
              data: nodeId
            })
          }
        ]
      });
      api.addTimelineLayer({
        label,
        color,
        id: DEVTOOLS_ID,
        skipScreenshots: true
      });
      api.on.getInspectorTree(inspectorTreeHook);
      api.on.getInspectorState(inspectorStateHook);
      api.on.editInspectorState(inspectorEditHook);
      eventBus.on(EVENTS.mutation.success, successMutationHook);
      eventBus.on(EVENTS.mutation.error, errorMutationHook);
      eventBus.on(EVENTS.devtools.update, () => {
        api.sendInspectorTree(DEVTOOLS_ID);
        api.sendInspectorState(DEVTOOLS_ID);
      });
    });
  };
}
export {
  createDevtoolsPlugin as default
};
//# sourceMappingURL=@harlem_plugin-devtools.js.map
